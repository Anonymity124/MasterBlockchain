# 比特币应用

现在，让我们从比特币作为一个应用平台的角度来看，进一步加强理解。 现在很多人使用“blockchain”(区块链)这个词来表示任何共享了比特币设计原则的应用平台。 该术语经常被滥用，并被应用于许多不能提供比特币区块链主要功能的事情。

在本章中，我们将介绍比特币区块链作为应用平台所提供的功能。 我们将考虑应用程序构建原语，即构成任何区块链应用程序的构建块。 我们将研究使用这些原语的几个重要应用程序，例如彩色币，付款（状态）渠道和路由支付渠道（闪电网络）。


## 12.5 合约币（Counterparty）

合约币是在比特币之上建立的协议层。与“染色币”类似的“合约币协议”提供了创建和交易虚拟资产和代币的能力。此外，合约币提供了去中心化的资产交换。合约币还在实施基于Ethereum虚拟机（EVM）的智能合同。

像染色币协议一样，合约币使用OP_RETURN操作码或1-N多重签名的公钥地址将元数据嵌入到比特币交易中，该地址用于代替公共密钥进行元数据编码。使用这些机制，合约币实现了在比特币交易中编码的协议层。额外的协议层可以由能理解合约币的应用程序来解读，如钱包和区块链浏览器，或使用合约币库（library）构建的任何应用程序。

反过来合约币可以用作给其他应用程序和服务的平台。例如，Tokenly是一个建立在合约币之上的平台，允许内容创作者，艺术家和公司发行表达数字所有权的代币，并可用于租赁，访问，交易或购买内容，产品和服务。利用交易合约币的其他应用包括游戏（Spells of Genesis）和网格计算项目（(Folding Coin）。

更多关于合约币的内容参见[https://counterparty.io](https://counterparty.io/)。开源项目可以在<https://github.com/CounterpartyXCP>中找到。

## 12.6 支付通道和状态通道

支付通道是在比特币区块链之外双方之间交换的比特币交易的无信任机制。这些交易，如果在比特币区块链上结算，则是有效的，然而他们却是在链外被持有的，以期票的形式等待最终批量结算。由于交易尚未结算，因此他们可以在没有通常的结算延迟的情况下进行交换，从而可以满足极高的交易吞吐量，低（亚毫秒）延迟和精细（satoshi级）粒度。

实际上，*通道* 一词是一个比喻。状态通道是区块链外，由双方之间的交换状态代表的虚拟结构。实际上没有“渠道”，底层数据传输机制并不是渠道。我们使用通道这个术语来表示链外双方之间的关系和共享状态。

为了进一步解释这个概念，想一想TCP流。从高层协议的角度来看，它是一个横跨互联网连接两个应用程序的“socket”。但是，如果您查看网络流量，TCP流只是IP数据包之上的虚拟通道。 TCP流的每个端点通过排序并组装IP数据包以产生字节流的错觉。实际上在背后，所有的数据包都是断开分散的。同理，支付通道只是一系列交易。如果妥善排序和连接，即使您不信任通道的另一方，（经过排序连接后的交易）也可以创建可以信任的可兑换的债务。

在本节中，我们将介绍各种形式的支付通道。首先，我们将检视用于构建计量小额支付服务（如流媒体视频）的单行（单向）支付通道的机制。然后，我们将扩大这一机制，引入双向付费渠道。最后，我们将看看首先在 *闪电网络* 中提出的，如何将路由网络中的双向通道端到端链接从而形成多跳通道。

支付通道是 状态通道的引申概念之一，代表了链外状态的变化，通过区块链上的最终的结算得到保障。支付通道是一种状态通道，其中被改变的状态是虚拟货币余额。

### 12.6.1 状态通道基本概念和术语

通过一个交易在区块链上所锁定的共享状态，在交易两方之间建立了一个状态通道。这被称为资金交易或锚点交易。这笔交易必须传送到网络并开始挖矿被挖矿确认以建立通道。在支付通道的示例中，锁定的状态即为通道的初始余额（以货币计）。

随后双方交换已签名的交易，这被称为“承诺交易”。承诺交易会改变初始状态。这些交易都是有效的，因为任何一方都可以提交结算的请求，不需要等到通道关闭再做结算。任何一方给对方创建、签名和发送交易时就会更新状态。实践中，这意味着每秒可进行数千笔交易。

当交换承诺交易时，双方同时废止之前的状态，如此一来最新的承诺交易总是唯一可以赎回的承诺交易。这样可以防止任何一方在通道中某个先前状态比最新状态更有利于己方的时候通过单方面关闭通道来进行欺骗。我们将在本章的其余部分中检视可用于废止先前状态的各种机制。

最后，通道可以合作关闭，即向区块链提交最后的结算交易，或者单方面由任何一方提交最后承诺交易到链上。单方面关闭的选项是必要的，以防万一交易中的一方意外断开连接。结算交易代表通道的最终状态，并在链上进行结算。

在通道的整个生命周期中，只有两个交易需要提交给链上进行挖矿：资金交易和结算交易。在这两个状态之间，双方可以交换任何数量的承诺交易，任何其他人永远不会看到，也不会提交到链上。

下图12-4说明了Bob和Alice之间的支付通道，显示了资金，承诺和结算交易。

[![图12-4. Bob和Alice之间的支付通道，显示了资金，承诺和结算交易](https://camo.githubusercontent.com/58b5342dee25c341ccf11efa48326ad6d9f1431e/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313738353935392d313833643130393262656266383861302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)](https://camo.githubusercontent.com/58b5342dee25c341ccf11efa48326ad6d9f1431e/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313738353935392d313833643130393262656266383861302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

### 12.6.2 简单支付通道示例

要说明状态通道，我们必须从一个非常简单的例子开始。 我们展示一个单向通道，意味着价值只向着一个方向流动。 为了便于解释，我们以一个天真的假设开始，假设没有人要试图欺骗他人。 一旦我们解释了基本的通道概念，我们将会接着看看是什么使得支付通道可以无信任化，从而让交易双方哪怕去尝试进行欺骗都无法成功。

对于这个例子，我们假设两个参与者：Emma和Fabian。 Fabian提供由微支付通道支持以秒为单位时长计费的视频流服务。Fabian每秒视频收费0.01毫比（millibits）（0.00001 BTC），相当于每小时36毫比（0.036 BTC）的视频。 Emma是从Fabian那里使用以秒计费的支付通道来购买流媒体视频服务的用户。下图12-5显示Emma使用支付通道从Fabian购买视频流服务。

[![图12-5.Emma使用以秒计费的支付通道从Fabian购买视频流服务](https://camo.githubusercontent.com/885c851a60310739b1ce367bc8017ea069b71e3e/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313738353935392d366437393639323266333333333463312e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)](https://camo.githubusercontent.com/885c851a60310739b1ce367bc8017ea069b71e3e/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313738353935392d366437393639323266333333333463312e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

在这个例子中，Fabian和Emma正在使用专门的处理支付通道和视频流的软件。 Emma在浏览器中运行该软件，Fabian从服务器端运行该软件。该软件包括基本的比特币钱包功能，可以创建和签署比特币交易。“支付通道”的概念和术语对于用户都是完全不可见的。他们看到的是以秒为单位支付了的视频。

为了设置支付通道，Emma和Fabian建立了一个2-2的多重签名地址，双方各持一个密钥。从Emma的角度来看，她的浏览器中的软件提供了一个带有P2SH地址的二维码（以“3”开头），并要求她提交最多1小时视频的“押金”。该地址因而得到了Emma的注资。支付给该多重地址的Emma交易，就是支付通道的资金交易或锚点交易。

就这个例子而言，我们假设Emma支付了36个毫比（0.036 BTC）到通道中。这将允许Emma消费长达1小时的流媒体视频。这笔资金交易设定了可以在这个通道上发送的最大数量（数据量），即设置了通道容量。

资金交易从Emma的钱包中消耗一个或多个输入以集成资金。它创建一个价值为36毫比的输出，支付给Emma和Fabian之间共同控制的多重签名2-2地址。它也可能有一个作为找零钱到Emma的钱包的额外输出。

一旦资金交易得到确认，Emma可以开始观看视频。Emma的软件创建并签署一笔承诺交易，改变通道余额，将0.01毫比归入Fabian的地址，并退回给Emma的35.99毫比。Emma签署的交易消耗了由资金交易创造的36毫比输出，并创建了两个输出：一个用于找钱，另一个用于Fabian的付款。交易只是部分被签署了 - 它需要两个签名（2 - 2），但只有Emma的签名。当Fabian的服务器接收到此交易时，它会添加第二个签名（用于2-2输入），并将其返回给Emma并附带时长1秒的视频。现在双方都有谁都可以兑换的完全签署的承诺交易，这个承诺交易代表着通道中的最新正确余额。双方都不会将此交易广播到网络中。

在下一轮，Emma的软件创建并签署另一个承诺交易（承诺2号），该交易从资金交易中消耗相同的2-2输出。二号承诺交易分配一个0.2毫比的一个输出到Fabian的地址，还有一个一个输出为35.98毫比，作为找零返回给Emma的地址。这个新交易支付的是连续两秒的视频内容。 Fabian的软件签署并返回第二个承诺交易，再加上视频的另一秒内容。

利用上述的方法，Emma的软件继续向Fabian的服务器发送承诺交易，以换取流媒体视频。因为Emma观看了更多秒数的视频，通道中属于Fabian的钱逐渐累积变多。假设Emma观看600秒（10分钟）的视频，创建和签署600笔承诺交易。最后的承诺交易（＃600）将有两个输出，将通道的余额分成两半，分别为6毫比属于Fabian和30毫比属于Emma。

最后，Emma点击“停止”停止流媒体视频。 Fabian或Emma现在可以发送最终状态交易以进行结算。最后一笔交易即为结算交易，向Fabian支付所有Emma消费的视频，并向Emma退还资金交易中剩余的资金。

图12-6显示了Emma和Fabian之间的通道以及更新通道余额的承诺交易。

最后，只有两个交易记录在块上：建立通道的资金交易和在两个参与者之间正确分配最终余额的结算交易。

[![图12-6 Emma和Fabian之间的支付通道，承诺交易不断的更新通道余额](https://camo.githubusercontent.com/e30ea2c45783d671e8049e962be307ac5b2c7df5/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313738353935392d343961623438383339383634643430642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)](https://camo.githubusercontent.com/e30ea2c45783d671e8049e962be307ac5b2c7df5/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313738353935392d343961623438383339383634643430642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

### 12.6.3 制造无需信任的通道

我们刚刚描述的通道只有在双方合作，没有任何失败或企图欺骗的情况下工作。我们来看看破坏这个通道的一些场景，并且看看需要什么来修复这类场景：

- 一旦资金交易发生，Emma需要Fabian的签名才能获得给自己的找零。如果Fabian消失，Emma的资金将被锁定在2-2中，并彻底损失。这个通道一旦建立，如果在双方共同签署至少一个承诺交易之前，有任何一方断开，就会导致资金的流失。
- 当通道正在运行时，Emma可以采取Fabian已经签署的任何承诺交易，并将它发回链上。如果她可以发送承诺交易＃1，只支付1秒的视频，为什么要支付600秒的视频？通道失败是因为Emma可以通过广播对她比较有利的先前的承诺来欺骗。

这两个问题都可以用时间锁(timelocks)来解决 - 我们来看看我们如何使用交易级时间锁（nLocktime）。

除非她有保证的找零退款，否则Emma不能冒风险进行2-of-2 签名。为了解决这个问题，Emma同时建立了资金和退款交易。她签署资金交易，但不传送给任何人。Emma只将退款交易传送给Fabian，并获得他的签名。

退款交易作为第一承诺交易，其时间锁确立了通道生命的上限。在这种情况下，Emma可以将nLocktime设置为30天或将来的第4320个区块。所有后续承诺交易必须具有较短的时间锁，以便在退款交易之前能把它们赎回。

现在，Emma已经有一个完全签署的退款交易，她可以自信地发送签署过的资金交易，因为她知道她最终可以在时间到期后最终赎回退款交易，即使Fabian消失也不会有问题。

在通道生命中双方交换的每一项承诺交易都会被时间锁锁进未来时间点。但是，对于每个承诺，延迟时间会稍短一点，所以最新的承诺可以在被它废止的前一承诺之前被赎回（译者注：上文提到如果有个最新承诺，前面的承诺就已经作废）。由于nLocktime，任何一方都只有其时间到期后才能成功传播任何承诺交易。如果一切顺利，他们将合作并通过结算交易合理地关闭通道，这样一来发送中间的承诺交易就不必要了。实质上说，承诺交易只在一方断线而另一方不得不单方面关闭通道时才使用。

例如，如果将来承诺交易＃1被时间锁定到将来的第4320个块，则将来承诺交易＃2被时间锁定到将来的4319个块。（同理可知）承诺交易＃600则可以在承诺交易＃1变为有效之前600个块的时间被消费。

图12-7显示每个承诺交易设置较短的时间锁，允许在它在之前的承诺变为有效前被花费

[![图12-7. 每个承诺交易设置较短的时间锁，允许在它在之前的承诺变为有效前被花费 ](https://camo.githubusercontent.com/31efbdf647e92af331af447ef95f00ca604f4a31/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313738353935392d616662386639396532646232633530612e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)](https://camo.githubusercontent.com/31efbdf647e92af331af447ef95f00ca604f4a31/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313738353935392d616662386639396532646232633530612e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

每个后续承诺交易必须具有较短的时间锁，以便可以在其前任之前和退款交易之前进行广播。能够尽早广播承诺交易的能力确保了承诺交易能够花费资金输出，并排除任何其他承诺交易通过花费资金输出来赎回。比特币区块链提供的担保，即防止双重支出和执行时间锁定，有效地允许每个承诺交易废止其前任有效性。

状态通道使用时间锁来在时间维度中执行智能合约。在这个例子中，我们看到时间维度如何保证最近的承诺交易在任何早先的承诺之前变得有效。因此，最近的承诺交易可以传输，消费输入和使先前的承诺交易无效。绝对时间锁定的智能合同的执行可以防止其中任何一方的欺骗。此实现只需要绝对的交易级时间锁（nLocktime）。接下来，我们将看到如何使用脚本级时间锁定，CHECKLOCKTIMEVERIFY和CHECKSEQUENCEVERIFY来构建更灵活，有用和复杂的状态通道。

第一次出现的单向支付通道在2015年由阿根廷开发商团队演示为视频流应用样板。你仍然可以在streamsium.io看到它。

时间锁并不是使先前的承诺交易无效的唯一方法。在接下来的章节中，我们将看到如何使用撤销密钥来实现相同的结果。时间锁是有效的，但其有两个明显的缺点。在通道首次打开时建立最大时间锁，限制了通道的使用寿命。更糟糕的是，他们迫使通道实现以在允许长期通道，和迫使其中一位参与者在提前关闭的情况下等待很长时间的退款之间取得平衡。例如，如果允许频道保持开放30天，通过将退款时间设置为30天，如果其中一方立即消失，则另一方必须等待30天才能退款。终点设置越远，退款时间越远。

第二个问题是，由于每个后续的承诺交易必须减短时间锁，所以在双方之间可以交换的承诺交易数量有明确的限制。例如，一个30天的通道，设置了位于未来第4320个块的时间锁**，**在必须被关闭前只能容纳4320个中间承诺交易。将时间锁定承诺交易的间隔设置为1个区块存在危险。通过将承诺交易之间的时间锁设置为1个区块，开发者给通道参与者带来了非常高的负担，参与者必须保持警惕，保持在线并监视，并随时准备传送正确的承诺交易。

现在我们了解如何使用时间锁来使先前的承诺无效，我们可以看到合作关闭通道和通过广播承诺交易单方面关闭通道之间的区别。所有承诺交易都是时间锁定的，因广播承诺交易总是要等待时间到期。但是，如果双方同意最后的余额是多少，并且知道他们都承担最终实现余额的承诺交易，那么他们可以构建一个没有时间锁代表相同余额的结算交易。在合作关闭中，任一方都可以提取最近的承诺交易，并建立一个各方面完全相同的结算交易，唯一差别就是结算交易省略了时间锁。双方都可以签署这笔结算交易，因为知道无法作弊以得到更多的余额。通过合作签署和发送结算交易，可以立即关闭通道并兑换余额。最差的情况下，当事人之一可以是卑鄙小人，拒绝合作，强迫另一方单方面关闭最近的承诺交易。但是如果他们这样做，他们也必须等待他们的资金。

### 12.6.4 不对称可撤销承诺

处理先前承诺状态的更好方法是明确撤销它们。但是，这不容易实现。比特币的一个关键特征是，一旦交易有效，它一直有效，不会过期。取消交易的唯一方法是在交易被挖矿前用另一笔交易双重支出它的输入。这就是为什么我们在上述简单支付通道示例中使用时间锁定，以确保最新的承诺交易可以在旧承诺生效之前被花费。然而，把承诺在时间上排序造成了许多限制，使得支付通道难以使用。

虽说一个交易无法取消，但是它可以被构造成无法再使用的样子。我们这样做我们实现它的方法是通过给予每一方一个撤销密钥，如果对方试图欺骗，可以用来进行惩罚。撤销先前承诺交易的这种机制首先被作为闪电网络的一部分提出。

为了解释撤销密钥，我们将在由Hitesh和Irene经营的两个交易所之间构建一个更加复杂的支付通道。Hitesh和Irene分别在印度和美国运营比特币交易所。 Hitesh的印度交易所的客户经常向Irene的美国交易所的客户发送付款，反之亦然。目前，这些交易发生在比特币链上，但这意味着支付手续费用并等待几个块进行确认。在交易所之间设置支付通道将大大降低成本并加快交易流程。

Hitesh和Irene通过合作建立资金交易来启动通道，每人向通道注资5个比特币。初始余额为Hitesh有5比特币且Irene有5比特币。资金交易将通道状态锁定在2-2多重签名中，就像在简单通道的例子中一样。

资金交易可能有一个或多个来自Hitesh的输入（加起来5个比特币或更多），以及Irene的一个或多个输入（加起来5个比特币或更多）。投入必须略微超过通道容量才够支付交易费用。该交易有一个将总共10个比特币锁定到由Hitesh和Irene控制的2-of-2多重地址的输出。如果他们的输入超过他们需要贡献的数值，资金交易也可能有一个或多个输出将找零返回给Hitesh和Irene。这是由双方提供和签署的多个输入形成的单一交易。在发送之前，它必须被合作构建起来并且由各方签署。

现在，代替双方签署单一承诺交易的是，Hitesh和Irene创造了两个不对称 的承诺交易。

Hitesh有一个带有两个输出的承诺交易。第一个输出立即支付Irene欠她的5比特币。第二个输出支付Hitesh欠他自己的5比特币，但条件是只有在1000个区块的时间锁之后。交易输出如下所示：

```
Input: 2-of-2 funding output, signed by Irene 

Output 0 <5 bitcoin>:
    <Irene's Public Key> CHECKSIG

Output 1:
    <1000 blocks>
    CHECKSEQUENCEVERIFY
    DROP
    <Hitesh's Public Key> CHECKSIG
```

Irene有带有两个输出的不同的承诺交易。 第一个输出支付Hitesh欠他的5比特币。 第二个输出支付Irene，欠她自己的5比特币，但同样只有经过1000个区块的时间锁。 Irene持有的承诺交易（由Hitesh签署）看起来像这样：

```
Input: 2-of-2 funding output, signed by Hitesh

Output 0<5 bitcoin>:
    <Hitesh's Public Key> CHECKSIG

Output 1:
    <1000 blocks>
    CHECKSEQUENCEVERIFY
    DROP
    <Irene's Public Key> CHECKSIG
```

这样一来，双方各有一笔承诺交易，以花费2 -2的资金输出。 该承诺交易的输入是由对方签署的。 在任何时候，持有承诺交易的一方都可以签字（完成2-2签名）并进行广播。 然而，如果他们广播承诺交易，承诺交易会立即支付对方，而他们自己的必须等待短时间锁到期。通过在其中一个输出强制执行赎回拖延,我们可以做到让各方在选择单方面广播承诺交易时处于轻微的不利地位。 但是单靠时间延迟还不足以鼓励公平的行为。

下图12-8显示两个不对称承诺交易，其中承诺持有人的有延迟支付 ![图12-8显示两个不对称承诺交易，其中承诺持有人的有延迟支付](https://camo.githubusercontent.com/4fb604873e4f374f40207b990c4fcb203ce59326/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313738353935392d346161373331663063666666336164642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

现在我们介绍这个方案的最后一个要素：一个撤销密钥，允许被欺诈的一方通过占有通道的所有余额来惩罚骗子。

每个承诺交易都有一个“延迟”的输出。 该输出的兑换脚本允许一方在1000个区块后兑换它，或者另一方如果拥有撤销密钥也可兑换它。 所以当Hitesh为Irene签署承诺交易时，他将把第二个输出定义为在1000块之后可输出支付给自己，或者是任何可以出示撤销密钥的人。 Hitesh构建了这个交易，并创建了一个由他秘密保管的撤销密钥。当他准备转移到新的通道状态并希望撤销这一承诺时， 他才会把撤销密钥透露给Irene 第二个输出脚本如下所示：

```
Output 0<5 bitcoin>:
    <Irene's Public Key> CHECKSIG

Output 1<5 bitcoin>:
IF # Revocation penalty output
    <Revocation Public Key>
ELSE
    <1000 blocks>
    CHECKSEQUENCEVERIFY
    DROP
    <Hitesh's Public Key>
ENDIF
CHECKSIG
```

Irene可以自信地签署这笔交易，因为一旦被发送它将立即支付她被欠的欠款。 Hitesh持有交易，但知道如果他在单方通道关闭时发送，他将不得不等待1000个块才能获得支付。

当通道进入下一个状态时，Hitesh必须在Irene同意签署下一个承诺交易之前撤销此承诺交易。要做到这一点，他所要做的就是将撤销密钥发送给Irene。一旦Irene拥有这一承诺的撤销密钥，她就可以自信地签署下一个承诺。她知道，如果Hitesh试图通过发布先前的承诺交易来作弊，她可以使用撤销密钥来兑换Hitesh的延迟输出。如果Hitesh作弊，Irene会得到BOTH（两方）输出。

撤销协议是双边的，这意味着在每一轮中，随着通道状态的进一步发展，双方交换新的承诺，交换用于之前承诺的撤销密钥，并签署彼此的承诺交易。当他们接受新的状态时，他们通过给予对方必要的撤销密钥来惩罚任何作弊行为，使先前的状态不可能再被使用。

我们来看一个它的工作例子。 Irene的客户之一希望向Hitesh的客户发送2比特币。要通过通道传输2比特币，Hitesh和Irene必须更新通道状态以反映新的余额。他们将承诺一个新的状态（状态号2），通道的10个比特币分裂，7个比特币属于Hitesh和3个比特币属于Irene。为了更新通道的状态，他们将各自创建反映新通道余额的新承诺交易。

如上述内容所说，这些承诺交易是不对称的，所以每一方所持的承诺交易都迫使他们等待兑换。至关重要的是，在签署新的承诺交易之前，他们必须首先交换撤销密钥以使先前的承诺无效。在这种情况下，Hitesh的利益与通道的真实状态是一致的，因此他没有理由广播先前的状态。然而，对于Irene来说，状态号1中留给她的余额比状态2中的更高。当Irene给予Hitesh她以前的承诺交易（状态号1）的撤销密钥时，她实际上废除了自己可以回滚通道状态到前一状态而从中获益的能力。因为有了撤销密钥，Hitesh可以毫不拖延地兑换先前承诺交易的两个输出。也就是说一旦Irene广播先前的状态，Hitesh可以行使其占有所有输出的权利。

重要的是，撤销不会自动发生。虽然Hitesh有能力惩罚Irene的作弊行为，但他必须勤勉地观察区块链中作弊的迹象。如果他看到先前的承诺交易广播，他有1000个区块时间采取行动，并使用撤销密钥来阻止Irene的欺骗行为并占有所有余额也就是全部10比特币来惩罚她。

带有相对时间锁（CSV）的不对称可撤销承诺是实现支付通道的更好方法，也是区块链技术非常重要的创新。通过这种结构，通道可以无限期地保持开放，并且可以拥有数十亿的中间承诺交易。在闪电网络的原型实现中，承诺状态由48位索引识别，允许在任何单个通道中有超过281兆（2.8×10^14）个状态转换！

### 12.6.5 哈希时间锁合约（Hash Time Lock Contracts，HTLC）

支付通道可以通过特殊类型的智能合同进一步扩展，以允许参与者将资金用于可赎回的具有到期时间的秘密（secret）。 此功能称为哈希时间锁定合约或HTLC，并用于双向和路由的支付通道。

首先我们来解释HTLC的“哈希”部分。 要创建一个HTLC，预期的收款人将首先创建一个秘密（secret）R。他们然后计算这个R的哈希H：

```
H = Hash\(R\)
```

这步产生可以包含在输出的锁定脚本中的哈希H。 知道秘密的任何人可以用它来兑换输出。 秘密R也被称为哈希函数的*前图像*。 前图像就是用作哈希函数输入的数据。

HTLC的第二部分是“时间锁”组件。 如果秘密没有被透露，HTLC的付款人可以在一段时间后得到“退款”。 这是通过使用绝对时间锁CHECKLOCKTIMEVERIFY来实现的。实现HTLC的脚本可能如下所示：

```
IF
   # Payment if you have the secret R
   HASH160 <H> EQUALVERIFY
ELSE
  # Refund after timeout.
  <locktime>
  CHECKLOCKTIMEVERIFY DROP
  <Payee Pubic Key> CHECKSIG
ENDIF
```

任何知道可以让哈希等于H的对应秘密R的人，可以通过行使IF语句的第一个子句来兑换该输出。

如果秘密没有被透露，HTLC中写明了，在一定数量的块之后，收款人可以使用IF语句中的第二个子句申请退款。

这是HTLC的基本实现。 任何 拥有秘密R的人都可以兑换这种类型的HTLC。通过对脚本进行微调，HTLC可以采用许多不同的形式。 例如，在第一个子句中添加一个CHECKSIG运算符和一个公钥来限制将哈希值兑换成一个指定的收件人，这个人必须知道秘密R.

## 12.8 结论

我们仅研究了几个可以使用比特币区块链作为信任平台构建的新兴应用程序。这些应用程序将比特币的范围扩大到超出付款和超越金融工具的范围，以涵盖许多信任至关重要的其他应用程序。通过去中性化的信任基础，比特币区块链是一个会释放将在各种行业中产生许多革命性应用的平台。