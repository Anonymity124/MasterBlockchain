# 软分叉

<!-- TOC -->

- [软分叉](#%E8%BD%AF%E5%88%86%E5%8F%89)
    - [软分叉重新定义NOP操作码](#%E8%BD%AF%E5%88%86%E5%8F%89%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89nop%E6%93%8D%E4%BD%9C%E7%A0%81)
        - [其他方式软分叉升级](#%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F%E8%BD%AF%E5%88%86%E5%8F%89%E5%8D%87%E7%BA%A7)
    - [对软分叉的批评](#%E5%AF%B9%E8%BD%AF%E5%88%86%E5%8F%89%E7%9A%84%E6%89%B9%E8%AF%84)
    - [使用区块版本发出软分叉信号](#%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%9D%97%E7%89%88%E6%9C%AC%E5%8F%91%E5%87%BA%E8%BD%AF%E5%88%86%E5%8F%89%E4%BF%A1%E5%8F%B7)
    - [BIP-34信号和激活](#bip-34%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%BF%80%E6%B4%BB)
    - [BIP-9信号和激活](#bip-9%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%BF%80%E6%B4%BB)

<!-- /TOC -->

并非所有共识规则的变化都会导致硬分叉。只有前向不兼容的共识规则的变化才会导致分叉。如果共识规则的改变也能够让未修改的客户端仍然按照先前的规则对待交易或者区块，那么就可以在不进行分叉的情况下实现共识修改。这就是软分叉，来区分之前的硬分叉。实际上软分叉不是分叉。软分叉是与共识规则的前向兼容并作些变化，允许未升级的客户端程序继续与新规则同时工作。

软分叉的一个不是很明显的方面就是，软分叉级只能用于增加共识规则约束，而不是扩展它们。为了向前兼容，根据新规则创建的交易和块也必须在旧规则下有效，但是反之亦然。新规则只能增加限制，否则，根据旧规则创建的交易和区块被拒绝时，还是会将触发硬分叉。

软叉可以通过多种方式实现，该术语不定义单一方法，而是一组方法，它们都有一个共同点：它们不要求所有节点升级或强制非升级节点必须脱离共识。

## 软分叉重新定义NOP操作码

基于NOP操作码的重新解释，在比特币中实现了一些软分叉。 Bitcoin脚本有10个操作码保留供将来使用，NOP1到NOP10。根据共识规则，这些操作码在脚本中的存在被解释为无效的运算符，这意味着它们没有任何效果。 在NOP操作码之后继续执行，就好像它不存在一样。因此，软叉可以修改NOP代码的语义给它新的含义。

例如，BIP-65（CHECKLOCKTIMEVERIFY）重新解释了NOP2操作码。实施BIP-65的客户将NOP2解释为OP\_CHECKLOCKTIMEVERIFY，并在其锁定脚本中包含该操作码的UTXO上，强制了绝对锁定的共识规则。这种变化是一个软分叉，因为在BIP-65下有效的交易在任何没有实现（不了解）BIP-65的客户端上也是有效的。 对于旧的客户端，该脚本包含一个NOP代码，这被忽略。

### 其他方式软分叉升级

NOP操作码的重新解释既是计划的，也是共识升级的明显机制。然而，最近，引入了另一种软分叉机制，其不依赖于NOP操作码，用于非常特定类型的共识改变。这在隔离见证掌机\[segwit\]中有更详细的检查。 Segwit是一个交易结构的体系结构变化，它将解锁脚本（见证）从交易内部移动到外部数据结构（将其隔离）。

Segwit最初被设想为硬分叉升级，因为它修改了一个基本的结构（交易）。在2015年11月，一位从事比特币核心工作的开发人员提出了一种机制，通过这种机制，可以将软件包引入segwit。用于此的机制是在segwit规则下创建的UTXO的锁定脚本的修改，使得未修改的客户端将任何解锁脚本视为可锁定脚本。

因此，可以引入segwit就是软分叉，而不需要每个节点必须从链上升级或拆分网络。有可能还有其他尚未被发现的机制，通过这种机制可以以向前兼容的方式进行升级，都作为软分叉。

## 对软分叉的批评

基于NOP操作码的软分叉是相对无争议的。 NOP操作码被放置在比特币脚本中，明确的目标是允许无中断升级。然而，许多开发人员担心软分叉升级的其他方法会产生不可接受的折衷。

对软分叉更改的常见批评包括：

- 技术性债务：由于软叉在技术上比硬叉升级更复杂，所以引入了技术性债务，这是指由于过去的设计权衡而增加代码维护的未来成本。代码复杂性又增加了错误和安全漏洞的可能性。
- 验证放松：未经修改的客户端将交易视为有效，而不评估修改的共识规则。实际上，未经修改的客户端不会使用全面的协商一致的规则来验证，因为它们对新规则无视。这适用于基于NOP的升级，以及其他软分叉升级。
- 不可逆转升级：因为软分叉产生额外的共识约束的交易，所以它们在实践中成为不可逆转的升级。如果软分叉升级在被激活后被回退，根据新规则创建的任何交易都可能导致旧规则下的资金损失。例如，如果根据旧规则对CLTV交易进行评估，则不存在任何时间锁定约束，并且可以花费在任何时间。因此，评论家认为，由于错误而不得不被回退的失败的软分叉几乎肯定会导致资金的流失。

## 使用区块版本发出软分叉信号

由于软分叉允许未经修改的客户在协商一致的情况下继续运作，“激活”软分叉的机制是通过向矿工发出信号准备：大多数矿工必须同意他们准备并愿意执行新的共识规则。 为了协调他们的行动，有一个信号机制，使他们能够表达他们对共识规则改变的支持。该机制是在2013年3月激活BIP-34并在2016年7月被BIP-9激活所取代。

## BIP-34信号和激活

在BIP-34中的第一个实施使用块版本字段来允许矿工表示准备达成特定的共识规则更改。在BIP-34之前，按照惯例将块版本设定为“1”，而不是以共识方式执行。BIP-34定义了一个共识规则变更，要求将Coinbase交易的coinbade字段（输入）包含块高度。在BIP-34之前，Coinbase可以让矿工选择包含的任意数据。在BIP-34激活之后，有效块必须在Coinbase的开始处包含特定的块高度，并且使用大于或等于“2”的版本号进行标识。

为了标记BIP-34的更改和激活，矿工们将块版本设置为“2”而不是“1”。这没有立即使版本“1”块无效。一旦激活，版本“1”块将变得无效，并且将需要所有版本“2”块以包含Coinbase库中的块高度才能有效。

BIP-34基于1000个块的滚动窗口定义了两步启动机制。矿工将以“2”作为版本号来构建块，从而向BIP-34发出信号。严格来说，由于共识规则尚未被激活，这些区块还没有遵守新的共识规则，也就是将块高度包括在Coinbase交易中。

共识规则分为两个步骤激活：

如果75％（最近1000个块中的750个）标有版本“2”，则版本“2”块必须包含coinbase交易中的块高度，否则被拒绝为无效。版本“1”块仍然被网络接受，不需要包含块高度。这个新时期的新旧共识规则共存。

当95％（最近1000块中的950）是版本“2”时，版本“1”块不再被视为有效。版本“2”块只有当它们包含coinbase中的块高度（根据先前阈值）时才有效。此后，所有块必须符合新的一致性规则，所有有效块必须包含coinbase交易中的块高度。根据BIP-34规则成功发信号和激活后，该机制再次使用两次以激活软分叉：BIP-66标签的严格DER编码通过BIP-34信号通过块版本“3”激活，无效版本“2”块。BIP-65 CHECKLOCKTIMEVERIFY被块版本“4”的BIP-34信号激活，无效版本“3”块。

BIP-65激活后，BIP-34的信号和激活机制退出，并用下面描述的BIP-9信号传导机制代替。这个标准在[BIP-34\(Block v2, Height in Coinbase\)](https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki)中定义。

## BIP-9信号和激活

BIP-34，BIP-66和BIP-65使用的机制成功地激活了三个软分叉。然而，它又被替换了，因为它有几个限制：

通过使用块版本的整数值，一次只能激活一个软分叉，因此需要软分叉提议之间的协调以及对其优先级和排序的协议。

此外，由于块版本增加，所以机制并没有提供一种直接的方式来拒绝变更，而是提出一个不同的方法。如果老客户仍然在运行，他们可能会错误地将信号转换为新的更改，作为以前拒绝的更改的信号。

每个新的更改不可逆转地减少可用的供将来更改的块版本。

提出BIP-9来克服这些挑战，提高实施未来变化的速度和便利性。

BIP-9将块版本解释为bit字段而不是整型（int）字段。因为块版本最初作为整型（int32）字段，因此版本1到4，只有29位可用作bit字段。这留下29位，可以独立使用，同时在29个不同的提案上表示准备就绪。BIP-9还设置了信令和激活的最大时间。矿工们不需要永远发出信号。如果提案在TIMEOUT期间（在提案中定义）未激活，则该提案被视为被拒绝。该提议可以使用不同位的信令重新提交，更新激活周期。

此外，在TIMEOUT已经过去并且特征被激活或被拒绝之后，信令位可以被再次用于另一个特征而不会混淆。因此，多达29次更改可以并行发出信号，TIMEOUT后可将这些位“再循环”以提出新的更改。

**注意**虽然信令位可以重复使用或回收利用，但只要投票期间不重叠，BIP-9的作者就建议仅在必要时重复使用位; 主要是由于旧软件中的bug，可能会发生意外的行为。总之，我们不应该期望在所有29位都被使用一次之前看到重用。

建议的更改由包含以下字段的数据结构标识：名称用于区分提案的简短描述。 通常，BIP将该提案描述为“bipN”，其中N是BIP编号。位0到28，矿工使用的块版本中的位用于表示此提案的批准。开始时间信号开始的时间（基于中值时间过去或MTP），之后该位的值被解释为提示的信令准备。时间结束该时间（基于MTP），如果尚未达到激活阈值，则认为该更改被拒绝。

与BIP-34不同，BIP-9根据2016块的难度改变目标（retarget）周期，在整个间隔中计数激活信号。对于每个改变目标期间，如果提案的信号块的总和超过95％（2016中的1916），则该提案将在稍后的改变目标期间激活。BIP-9提供了一个提案状态图，以说明一个提案的各个阶段和转换，如图10-10所示。

![img](http://upload-images.jianshu.io/upload_images/1785959-4502b09278ed7c87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

一旦它们的参数在比特币软件中被知道（定义），提案将在DEFINED状态下开始。 对于具有MTP的块在开始时间之后，提议状态转换到STARTED。 如果在改变目标期间超过了投票阈值，并且未超过超时，则提案状态转换为LOCKED\_IN。 一个改变目标期后，该提案变为活动。

一旦达到这个状态，提案仍然处于活动状态。如果在达到投票阈值之前超时时间，提案状态将更改为“已故”，表示已拒绝的提案。REJECTED的建议永远在这个状态。BIP-9首次实施用于激活CHECKSEQUENCEVERIFY和相关BIP（68,112,113）。名为“csv”的建议在2016年7月成功启动。标准定义在[BIP-9\(Version bits with timeout and delay\)](https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki).